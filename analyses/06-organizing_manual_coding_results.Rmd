---
title: "06-organizing_manual_coding_results"
author: "Devi Veytia"
date: "2023-03-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
```

Note that I might need to match by doi with the db below to get corresponding duplicate_id and abstract

```{r join with full corpus database to get duplicate_id}

# metadata from full corpus
dbcon <- dbConnect(RSQLite::SQLite(), 
                   here::here("data","raw-data","sql-databases","all-refs_v2_join-duplicate_id.sqlite"), 
                   create = FALSE)
src_dbi(dbcon)
allrefs_join <- tbl(dbcon, "allrefs_join")

allrefs_join %>% collect() 

dbDisconnect(dbcon)


```



# Read in codebooks and format for distilBert

```{r format into binary columns for predictions in distilBERT}

## READ IN FILES

# files of coding results
codingDir <- here::here("data","derived-data","coding","manual-coding","set-1-to-18")
codingFiles <- dir(codingDir)
codingFiles <- codingFiles[grepl(".xl", codingFiles)] # only include excel files


for(f in 1:length(codingFiles)){
  
  print(paste("f = ", f))
  
  # read in but skip extra header rows and row indicating type of variable
  temp <- readxl::read_excel(file.path(codingDir, codingFiles[f]),sheet = "Codebook",
                             trim_ws = TRUE, skip = 3)
  
  
  # Column names
  colnames(temp) <- tolower(colnames(temp))
  colnames(temp) <- gsub(" ","_", colnames(temp))
  colnames(temp) <- gsub("[.]","_", colnames(temp))
  
  # change french formatting if needed
  temp[temp == "VRAI"] <- TRUE
  temp[temp == "FAUX"] <- FALSE
  
  
  ## If f == 1, build the template to expand answers
  # Extract possible values for each variable
  if(f==1){
    # each variable will be stored in a list
    responseList <- vector("list", length(values))
    names(responseList) <- colnames(temp)
    
    # all the possible values for each variable to search for
    values <- temp[1,]
  }
  
  # remove the row that contains all the possible variable values
  temp <- temp[-1,]
  
  # filter out rows where include_code=FALSE
  temp <- subset(temp, include_code == TRUE)
  
  ## For all the variables, spread factors into binary columns for each value
  for(j in 1:length(values)){
    
    print(paste("j = ", j))
    
    if(grepl("pre-filled",values[j], ignore.case = TRUE)){
      tempMat <- as.data.frame(temp[,j])
      colnames(tempMat) <- colnames(temp)[j]
      tempMat[,1] <- as.character(tempMat[,1])
    }  
    
    if(grepl("text",values[j], ignore.case = TRUE)){
      tempMat <- as.data.frame(temp[,j])
      colnames(tempMat) <- colnames(temp)[j]
      tempMat[,1] <- as.character(tempMat[,1])
    }
    
      
    if(grepl("integer", values[j], ignore.case = TRUE)){
      tempMat <- as.data.frame(temp[,j])
      colnames(tempMat) <- colnames(temp)[j]
      tempMat[,1] <- as.factor(tempMat[,1])
    }
    
    
    if(grepl("automatic fill", values[j], ignore.case = TRUE)){
      tempMat <- as.data.frame(temp[,j])
      colnames(tempMat) <- colnames(temp)[j]
      tempMat[,1] <- as.character(tempMat[,1])
    }
    
    if(grepl("alpha-numeric", values[j], ignore.case = TRUE)){
      tempMat <- as.data.frame(temp[,j])
      colnames(tempMat) <- colnames(temp)[j]
      tempMat[,1] <- as.character(tempMat[,1])
    }
    
    
    if(grepl("boolean", values[j], ignore.case = TRUE)){
      tempMat <- as.data.frame(temp[,j])
      tempMat <- ifelse(tempMat == "TRUE", 1, 0)
      tempMat[is.na(tempMat)] <- 0
      colnames(tempMat) <- colnames(temp)[j]
    }
    
    
    if(grepl("Select", values[j], ignore.case = TRUE)){
      
      if(grepl("Select One", values[j], ignore.case = TRUE)){
        vals <- unlist(strsplit(gsub("Select One: ","", values[j]),","))
      }else{
        vals <- unlist(strsplit(gsub("Select Multiple: ","", values[j]),","))
      }
      
      # remove leading/trailing spaces
      vals<-trimws(vals)
      
      # remove NA
      if("NA" %in% vals){
        vals <- vals[-which(vals == "NA")]
      }
      
      valLabels <- gsub(" ","_",gsub("[[:punct:]]","", vals))
      
      # for some reason grep has trouble with some punctuation so simplify to search for implemented
      if(length(grep("implemented",vals, ignore.case = TRUE))>0){
        vals[grep("implemented",vals, ignore.case = TRUE)] <- "Implemented"
      }
      if(length(grep("tourism",vals, ignore.case = TRUE))>0){
        vals[grep("tourism",vals, ignore.case = TRUE)] <- "tourism"
      }
      if(length(grep("mining",vals, ignore.case = TRUE))>0){
        vals[grep("mining",vals, ignore.case = TRUE)] <- "mining"
      }
      if(length(grep("macroalgae",vals, ignore.case = TRUE))>0){
        vals[grep("macroalgae",vals, ignore.case = TRUE)] <- "macroalgae"
      }
      if(length(grep("science",vals, ignore.case = TRUE))>0){
        vals[grep("science",vals, ignore.case = TRUE)] <- "science"
      }
      
      if(colnames(values)[j] == c("time_period")){
        vals <- c("Before pre-ind","Pre-industrial", "Modern","Forecast")
        valLabels <- vals # have to re-assign this because otherwise the column order won't match
      }
      if(colnames(values)[j] == c("marine_system")){
        vals <- c("estuary","land","coastal ocean","open-ocean","deep-ocean","unclear")
        valLabels <- vals
      }
      
      # make empty matrix to fill
      tempMat <- matrix(nrow = nrow(temp), ncol = length(vals))
      colnames(tempMat) <- valLabels
      
      # fill matrix with matches
      for(v in 1:length(vals)){
        tempMat[,v] <- grepl(vals[v], as.matrix(temp[,j]), ignore.case = TRUE)
      }
      tempMat <- as.data.frame(tempMat)
    }
    
    
    ## Final check to make sure all TRUE/FALSE is 0,1
    tempMat[tempMat==TRUE] <- 1
    tempMat[tempMat==FALSE] <- 0
    
    ## after all the processing, save
    
    if(f==1){
      responseList[[j]] <- tempMat
      #dbWriteTable(codingResultsDbCon, colnames(temp)[j], tempMat, append=FALSE)
      
    }else{
      responseList[[j]] <- rbind(responseList[[j]], tempMat)
      #dbWriteTable(codingResultsDbCon, colnames(temp)[j], tempMat, append=TRUE)
    }
    
    
  } # finish looping through columns
  
  # if(f == length(codingFiles)){
  #   dbDisconnect(codingResultsDbCon)
  # }
  
} # finish looping through files


responseDf <- do.call(cbind.data.frame, responseList)
responseDf$row_id <- ifelse(responseDf$row_id == "FALSE", NA,responseDf$row_id)

#View(responseDf)

# save vectors for lookup
variables <- colnames(temp)


```


```{r Join with abstract by using sysref_id }
# metadata from screening
load(here::here("data","derived-data","screening","screened-records","screen_results_merged.RData"))

screen_results_merged_sub <- screen_results_merged %>% 
  select(sysrev_id, abstract) %>%
  mutate(sysrev_id = as.character(sysrev_id)) 
rm(screen_results_merged)

# merge in with coding results
test <- merge.data.frame(responseDf[,1:3], screen_results_merged_sub, by="sysrev_id", all.x = TRUE, all.y=FALSE)
responseDf <- cbind(test, responseDf[,-c(1:3)])
rm(test)

## Write
write.table(
  responseDf,
  file = file.path(codingDir, "manual-coding-format-distilBERT.txt"),
  row.names=F, col.names=TRUE, sep='\t', quote=FALSE
)

```

# Evaluate if supplemental coding is needed 

Visualize frequencies to ensure balanced samples of most important variables: ORO_type, ORO_development_stage, Climate_threat, Impact_nature,  Restoration, Safe_fish, Safe_space


```{r}
# vector of variable names to tabulate
variables_to_tab <- c("ORO_type", "ORO_development_stage", "Climate_threat", "climate_mitigation", "adapt_to_threat", "Impact_nature",  "Restoration")

variables_to_tab <- variables

# index of which columns belong to which variables
variableInd <- unlist(lapply(strsplit(colnames(responseDf), "[.]"), function(x) x[[1]]))

# change to all variables
variables_to_tab <- unique(variableInd)
  
# empty list to fill with tabulated tables (one item for each variable)
tabulated_variables <- list()

for(v in 1:length(variables_to_tab)){
  colsInd <- grep(variables_to_tab[v], variableInd, ignore.case = TRUE)
  
  if(is.character(responseDf[,colsInd])){next} # can't tabulate character vectors
  
  if(!is.null(dim(responseDf[,colsInd]))){
    tab <- colSums(responseDf[,colsInd])
    names(tab) <- unlist(lapply(strsplit(colnames(responseDf)[colsInd], "[.]"), function(x) x[[2]]))
  }else{
    tab <- tabulate(responseDf[,colsInd])
  }
  tabulated_variables[[v]] <- tab
  names(tabulated_variables)[v] <- variables_to_tab[v]
}


sink(here::here("outputs","coding","tabulated_coding_round1.txt"))
print(tabulated_variables)
sink()

```







